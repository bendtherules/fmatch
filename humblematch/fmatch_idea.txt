fmatch
.matched
.wrap
.Any
.old_matched

list_ -> fmatch  -> [2,+(wrap([Int])*Any), [Any]*4 and fmatch(matched.len < old_matched[-1].len)  ] (1)
matches [2, 3,5,8,9,1, [1,2,3,4]]

*(wrap([Int])*Any) => *(wrap([Int]).times(Any))

list_ -> fmatch  -> [2,Any, wrap(int)*4 and (matched[0]*2 > 5 or all([m >6 for m in matched]) ] -> _, a, b


list_ -> fmatch  -> [2,Any*Any,5]

basically need a mock object of sorts which stores everything, tries to stop evaluation, so that invalid (wrt types,values) ones work. invalid syntax still wont work.


macros in python

pass in a string or function, have a great pattern matching like lisp and then do your own stuff ( like http://stackoverflow.com/questions/267862/what-makes-lisp-macros-so-special#4621882 )

look for reaasembler in python

(1) -> [2, multi_0, list(Any,Any,Any,Any)]


wrap([Int]) = wrap_obj(data =[Int])
creates wrap_obj with data = param and ops =[]
if ops are applied store them
apply right then correctly or later (???)



(wrap([Int, Float])*Any) = wrap_obj(data =[Int, Float], ops =[__mult__:Any])
if ops[__mult__] is Any and data is list:
 this == wrap_obj(data =[ wrap_multi_obj(data = [Int, Float],multi = Any, ops =None) ], ops =None)
if (data not list):
    # eg 2
    try normal __mult__ anyway
if ops[__mult__] is not Any:
    # eg [2,3]*5
    try normal __mult__ anyway

## Done
WrapObj
WrapMultiObj

## Done
wrap(Float).times(Any) == wrap_multi_obj(data = [Float],multi = Any, ops =None)
wrap([2,3.0]).times(Any) == wrap_multi_obj(data = [[2,3.0]],multi = Any, ops =None)
.times means the whole thing will repeat n times
first doing all ops and, replace wrap_obj with wrap_multi_obj putting new data=[data]
to repeat multiple items sequentially -> (2,3) say n times as in 2,3,2,3,2,3,.. do +(wrap([2,3.0]).times(Any))

### Not needed ###
+(wrap([Int])*Any) == wrap(Int).times(Any)
== wrap_multi_obj(data = [Int],multi = Any, ops =None)
if prev is wrap_obj and data is list:
    removes prev node, and replace with wrap_multi_obj with same data

+ is the unwrap op

XXXX
types of indirect matching

1. type-based (X This is what exact match does)
2. Checking subclass-tree (issubclass)
3. explicit conversion-based (converts 1st arg of fmatch to type of 2nd arg) -- usually quite good
4. ABC-based somewhat

try to use abc for multiple types

functional prog is like passing little chunks of data, however less you can. but you will lose sense of what data it is.
imperative prog is like having a structure of data and partially modifying it, yet sending the whole thing over.
if you know about every data, fp - like experts.
if you want to ask about everything, imp. safer in some sense

types like putting a label. one label attests to a number of similar properties, so if you got type use all those properties even with the assumptions that how they behave with each other

duck typing is like letting anyone with a known speciific skill work in your office. They dont need degrees or anything if they know that one thing very well which you'll need. And yes that is very flexible and democratic. But never assume that they will even have some related but different skill. Degrees attest to the fact that they know about a set of skills. All that cool.
Now if you have any more requirement, ask if they can do it and if they cant, fire them. Or force them to do it, if they fail fire them. But rest assured, you are more flexible so anyone with both those skills are welcome now, even the one you just fired if they end up learning that skill.

issue of flexibility vs reliability, you sometimes want both :)

Ceveats
This wont work
1. WrapObj({str:5}) == {"w":5} as dicts are not searched for key and yet they are ambiguous if searched. So, keys are taken for what they are, even if it is a class. So, here str is considered as the key

for mixed type:
allow this kind of things -> int or float("inf")

IDEAS TO DO

add more debug info
debug info or raise custom exception
better __repr__ print

allow matches to store in var (done)

add __mult__ alternative to .times (done)

what about dict ? (dicts ok, )

maybe dict to obj? (done)

save_as in multimatch with list behaviour(done)

Any and OR save_as (done)

name change to humblematch (done)

test if data == Multi branch, raise error doesnt break anything
more docs

test integration save_as and times

do smart .times for single value

allow Any with a module.Class(Any), which allows only object - Any

more doctest for other methods and helpers

test helpers

